import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
from sklearn.preprocessing import StandardScaler
import meshio
import pymeshlab
import pyomo.environ as pyo
import pyomo.opt as pyopt

### PWL approximation

Tw = np.linspace(50,80,32)
Gw = np.linspace(500,5000,32)
Tw_, Gw_ = np.meshgrid(Tw,Gw)
dfm = pd.DataFrame(np.concatenate([Tw_.reshape(-1,1), Gw_.reshape(-1,1)],axis=1), columns=['Tw','Gw'])
dfm['Qw'] = dfm['Tw']*dfm['Gw']/1000
Scaler_1 = StandardScaler()

dfmn = pd.DataFrame(data = Scaler_1.fit_transform(dfm),index=dfm.index, columns=dfm.columns)
meshio.write("TGQ.ply", mesh=meshio.Mesh(points=dfmn.values, cells = []), binary=False)
ms = pymeshlab.MeshSet()
ms.load_new_mesh("TGQ.ply")
ms.generate_surface_reconstruction_ball_pivoting()
ms.meshing_remove_unreferenced_vertices()
ms.save_current_mesh("TGQ.off",save_vertex_normal=False)
ms.meshing_decimation_quadric_edge_collapse(targetfacenum=33)
ms.save_current_mesh("TGQ_simple.off",save_vertex_normal=False,save_polygonal=True)
with open("TGQ_simple.off",'r') as f:
    lines = f.readlines()
vert_num, simp_num, _ = lines[1].split()
vert_num = int(vert_num)
simp_num = int(simp_num)
Simplex_list = [x[1:].split() for x in lines[vert_num+2:]]
dfs = pd.DataFrame([x.split() for x in lines[2:vert_num+2]], columns=['x','y','z']).astype(float)
dfs['sind'] = [[] for x in dfs.index]
for k,v in enumerate(Simplex_list):
    for vert in v:
        dfs.at[int(vert),'sind'] += [int(k)]  
dfs.columns =  list(dfm.columns) + ['simplex_numb']
dfs[dfm.columns] = Scaler_1.inverse_transform(dfs[dfm.columns])
df_TGQ = dfs.copy()
df_TGQ

dfm['flg'] = 0 
dfm2 = df_TGQ.iloc[:,:-1]
dfm2['flg'] = 1
px.scatter_3d(data_frame=pd.concat([dfm,dfm2],axis=0), x = 'Tw', y = 'Gw', z = 'Qw', color='flg',opacity=0.2)

# model generatiom

m = pyo.ConcreteModel()
def mesh_block(df):
    m = pyo.Block(concrete=True)
    x_ind = df.columns.to_list()[:-1]
    lambda_ind = list(range(len(df)))
    tmp1 = []
    for item in df['simplex_numb'].values:
        tmp1 += item
    simlex_ind = list(set(tmp1))
    m.x = pyo.Var(x_ind)
    m.lambdas = pyo.Var(lambda_ind, bounds=(0,1))
    m.simplex_indicator = pyo.Var(simlex_ind,within=pyo.Binary)
    m.constr_simplex_indicator = pyo.Constraint(expr=sum(m.simplex_indicator[j] for j in simlex_ind)==1)
    m.constr_lincomb = pyo.ConstraintList()
    for jn,jv in enumerate(x_ind):
        expr = - m.x[jv]
        for i in lambda_ind:
            expr += m.lambdas[i]*df.iloc[:,:-1].values[i,jn]
        m.constr_lincomb.add(expr==0)
    m.constr_convex_comb = pyo.Constraint(expr=sum(m.lambdas[j] for j in lambda_ind)==1)
    m.constr_triangulation = pyo.ConstraintList()
    for j in lambda_ind:
        expr = m.lambdas[j]
        for i in df.iloc[j,-1]:
            expr += -m.simplex_indicator[i]
        m.constr_triangulation.add(expr<=0)
    return m
m.TGQ =  mesh_block(df_TGQ)
top_x_list = []
for block_item in m.component_data_objects(pyo.Block):
    top_x_list += list(block_item.x.keys())
m.x = pyo.Var(top_x_list, within =pyo.NonNegativeReals)
m.x_meas = pyo.Var(top_x_list, within =pyo.NonNegativeReals)
measurements_metadata = {}
measurements_metadata['Tw'] = {'norm':70*0.005}
measurements_metadata['Gw'] = {'norm':5000*0.025}
measurements_metadata['Qw'] = {'norm':250*0.025}
measurements_list = list(measurements_metadata.keys())
m.residual = pyo.Var(measurements_list, bounds=(-999.99,999.99))
m.res2 = pyo.Var(measurements_list)
m.con1 = pyo.ConstraintList()
for block_item in m.component_data_objects(pyo.Block):
    for var_item in top_x_list:
        try:
            m.con1.add(expr = block_item.x[var_item] == m.x[var_item])
        except:
            pass
def res_rule(m,measurement):
    return m.residual[measurement] == (m.x[measurement] - m.x_meas[measurement])/measurements_metadata[measurement]['norm']
m.res_list = pyo.Constraint(measurements_list, rule=res_rule)
N = 16
g_range =  np.concatenate([np.array([-999.99]),np.linspace(-2.99,2.99,N),np.array([999.99])])
qdf = pd.DataFrame({'dW': g_range, 'dW2': (g_range**2).clip(0.0,9.0)})
def v2(b,measurement):
    b.PWL = pyo.Piecewise(m.res2[measurement], m.residual[measurement], pw_pts=list(qdf['dW'].values),
                      pw_constr_type='EQ', f_rule=list(qdf['dW2'].values), pw_repn='SOS2')
m.quad_v = pyo.Block(measurements_list, rule=v2)
m.Imbalance = pyo.Var()
m.Imbalance_contraint = pyo.Constraint(expr= m.Imbalance == sum(m.res2[measurement] for measurement in measurements_list))
m.obj = pyo.Objective(expr = m.Imbalance)
def update_measurements(m, measurements_values_list):
    measurements_names_list = list(measurements_values_list.keys())
    m.x_meas.unfix()
    m.res_list.deactivate()
    for measurement in measurements_names_list:
        m.x_meas[measurement].fix(measurements_values_list[measurement])
        m.res_list[measurement].activate() 
    return m
m.update_measurements = update_measurements

### example

measurements = {}
measurements['Tw'] =75.0
measurements['Gw'] = 3000.0
measurements['Qw'] = 225.0
m = m.update_measurements(m, measurements)
opt = pyo.SolverFactory('cbc')
opt.options["limits/gap"] = 0.0
opt.options["limits/absgap"] = 0.0
opt.options["limits/time"] = 2
status = opt.solve(m, tee=True)
m.x.display()

m.x['Tw'].value*m.x['Gw'].value/(m.x['Qw'].value*1000)
